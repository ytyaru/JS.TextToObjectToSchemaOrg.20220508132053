class TxtyError extends ExtensibleCustomError{}class TxtyItemError extends TxtyError{}class TxtyStoreError extends TxtyError{}class TxtyStoresError extends TxtyError{}class TxtyTreeError extends TxtyError{}class TxtyCompositeError extends TxtyError{}class Txty{static item(n,t=TxtyIndent.Space4){return new TxtyItemParser(t).parse(n)}static store(n,t=TxtyIndent.Space4){return new TxtyStoreParser(t).parse(n)}static stores(n,t=TxtyIndent.Space4){return new TxtyStoresParser(t).parse(n)}static tree(n,t=TxtyIndent.Space4){return new TxtyTreeParser(t).parse(n)}static composite(n,t=TxtyIndent.Space4){return new TxtyCompositeParser(t).parse(n)}static get Indent(){return TxtyIndent}}class TxtyIndent{static get Tab(){return"\t"}static get Space2(){return" ".repeat(2)}static get Space4(){return" ".repeat(4)}static get Space8(){return" ".repeat(8)}}class TxtyParser{constructor(n=TxtyIndent.Space4){this.LINES=null;this.INDENT=n}parse(n){this.LINES=n.trim().split(/\r\n|\n/)}setIndent(n){this.INDENT=n||this.INDENT||TxtyIndent.Space4}guessIndentText(){const n=["\t"].concat([2,4,8].map(n=>" ".repeat(n)));for(const t of this.LINES)return n.find(n=>t.startsWith(n));throw new TxtyTreeError(`インデント文字の推測に失敗しました。入力テキストのうち少なくともひとつの行の先頭にTABまたは半角スペース2,4,8のいずれかを含めてください。`);}}class TxtyItemParser extends TxtyParser{parse(n,t=null){if(super.setIndent(t),!n.trim())throw new TxtyItemError("引数lineには空白文字以外の字がひとつ以上必要です。");const i={},r=n.split(this.INDENT);return i.name=r[0],i.options=1<r.length?r.slice(1):[],i}}class TxtyStoreParser extends TxtyParser{parse(n){return super.parse(n),this.parseFromLines(this.LINES)}parseFromLines(n,t=null){if(!n[0]||0===n.length||0===n[0].trim().length)throw new TxtyStoreError(`引数linesは空白文字以外が1字以上ある文字列の要素が1つ以上必要です。`);super.setIndent(t);const i=[],r=new TxtyItemParser(this.INDENT);for(const n of n){if(!n)throw new TxtyStoreError(`途中に空行を含めることはできません。`);i.push(r.parse(n))}return i}}class TxtyStoresParser extends TxtyParser{parse(n){return super.parse(n),this.parseFromLines(this.LINES)}parseFromLines(n,t=null){super.setIndent(t);const i=TxtyBlock.blocks(n),r=new TxtyStoreParser(this.INDENT);return i.map(n=>r.parseFromLines(n))}}class TxtyTreeParser extends TxtyParser{parse(n,t=null){return super.parse(n),this.parseFromLines(this.LINES,t)}parseFromLines(n,t=null){t&&(this.INDENT=t);t||this.INDENT||(this.INDENT=super.guessIndentText());const i=this.makeRoot();if(1===n.length&&!n[0])return i;let[r,f]=[1,1];const u=[i],e=new TxtyItemParser(this.INDENT);for(const n of n){if(!n)throw new TxtyTreeError(`途中に空行があってはなりません。`);r=this.getDepth(n,i.indentText);this.validDepth(r,f);const t={content:e.parse(n.trim()),nodes:[]},o=this.getParent(u,r,f);i.maxDepth<u.length&&(i.maxDepth=u.length);o.nodes.push(t);f=r;u.push(t)}return i}makeRoot(){return{indentText:this.INDENT,maxDepth:1,nodes:[]}}getParent(n,t,i){return 1<n.length&&(i===t?n.pop():i<t||t<i&&[...Array(i-t+1)].map(()=>n.pop())),n[n.length-1]}validDepth(n,t){if(n<1)throw new TxtyTreeError(`テキストツリーの階層が不正です。depthは1以上であるべきです。${n}`);if(t<n&&t+1<n)throw new TxtyTreeError(`テキストの階層が不正です。前の行より2階層以上深いインデントです。深くするなら1層深くするだけにしてください。${n}, ${t}`);}getDepth(n,t){let i=1;while(n.startsWith(t.repeat(i)))i++;return i}}class TxtyCompositeParser extends TxtyParser{parse(n,t=null){super.setIndent(t);const i=[];if(super.parse(n),1===this.LINES.length&&!this.LINES[0])return i;const r=TxtyBlock.blocks(this.LINES);for(const n of TxtyBlock.blocks(this.LINES)){const t=this.isTree(n)?new TxtyTreeParser:new TxtyStoreParser;i.push(t.parseFromLines(n,this.INDENT))}return i}isTree(n){return n.some(n=>n.startsWith(this.INDENT))}}class TxtyBlock{static blocks(n){const t=this.ranges(n);return this.ranges(n).map(t=>n.slice(t.begin,t.end).filter(n=>n))}static ranges(n){if(!Array.isArray(n))throw new TxtyError(`引数LINESは配列であるべきです。`);if(0===n.length)return[];if(1===n.length)return[{begin:0,end:1}];const t=[];let[i,r]=[0,0,0];for(let u=0;u<n.length;u++)if(r++,!n[u]){for(t.push({begin:i,end:r});!n[u];)u++;if(u>=n.length)break;i=u;r=u}return t.push({begin:i,end:n.length}),t}}
