class TxtyError extends ExtensibleCustomError{}class TxtyLineError extends TxtyError{}class TxtyLinesError extends TxtyError{}class TxtyTreeError extends TxtyError{}class TxtyCompositeError extends TxtyError{}class Txty{static line(n,t=TxtyIndent.Space4){return new TxtyLineParser(t).generate(n)}static lines(n,t=TxtyIndent.Space4){return new TxtyLinesParser(t).generate(n)}static tree(n,t=TxtyIndent.Space4){return new TxtyTreeParser(t).generate(n)}static composite(n,t=TxtyIndent.Space4){return new TxtyCompositeParser(t).generate(n)}static get Indent(){return TxtyIndent}}class TxtyIndent{static get Tab(){return"\t"}static get Space2(){return" ".repeat(2)}static get Space4(){return" ".repeat(4)}static get Space8(){return" ".repeat(8)}}class TxtyParser{constructor(n=TxtyIndent.Space4){this.LINES=null;this.INDENT=n}generate(n){this.LINES=n.trim().split(/\r\n|\n/)}setIndent(n){this.INDENT=n||this.INDENT||TxtyIndent.Space4}guessIndentText(){const n=["\t"].concat([2,4,8].map(n=>" ".repeat(n)));for(const t of this.LINES)return n.find(n=>t.startsWith(n));throw new TxtyTreeError(`インデント文字の推測に失敗しました。入力テキストのうち少なくともひとつの行の先頭にTABまたは半角スペース2,4,8のいずれかを含めてください。`);}}class TxtyLineParser extends TxtyParser{generate(n,t=null){if(super.setIndent(t),!n.trim())throw new TxtyLineError("引数lineには空白文字以外の字がひとつ以上必要です。");const i={},r=n.split(this.INDENT);return i.name=r[0],i.options=1<r.length?r.slice(1):[],i}}class TxtyLinesParser extends TxtyParser{generate(n){return super.generate(n),this.generateFromLines(this.LINES)}generateFromLines(n,t=null){super.setIndent(t);const i=[],r=TxtyBlock.blocks(n);for(const n of TxtyBlock.blocks(n)){const t=[];for(const n of n)t.push(Txty.line(n,this.INDENT));i.push(t)}return i}}class TxtyTreeParser extends TxtyParser{generate(n,t=null){return super.generate(n),this.generateFromLines(this.LINES,t)}generateFromLines(n,t=null){t&&(this.INDENT=t);t||this.INDENT||(this.INDENT=super.guessIndentText());const i=this.makeRoot();if(1===n.length&&!n[0])return i;let[r,f]=[1,1];const u=[i];for(const n of n){if(!n)throw new TxtyTreeError(`途中に空行があってはなりません。`);r=this.getDepth(n,i.indentText);this.validDepth(r,f);const t={content:Txty.line(n.trim(),this.INDENT),nodes:[]},e=this.getParent(u,r,f);i.maxDepth<u.length&&(i.maxDepth=u.length);e.nodes.push(t);f=r;u.push(t)}return i}makeRoot(){return{indentText:this.INDENT,maxDepth:1,nodes:[]}}getParent(n,t,i){return 1<n.length&&(i===t?n.pop():i<t||t<i&&[...Array(i-t+1)].map(()=>n.pop())),n[n.length-1]}validDepth(n,t){if(n<1)throw new TxtyTreeError(`テキストツリーの階層が不正です。depthは1以上であるべきです。${n}`);if(t<n&&t+1<n)throw new TxtyTreeError(`テキストの階層が不正です。前の行より2階層以上深いインデントです。深くするなら1層深くするだけにしてください。${n}, ${t}`);}getDepth(n,t){let i=1;while(n.startsWith(t.repeat(i)))i++;return i}}class TxtyCompositeParser extends TxtyParser{generate(n,t=null){super.setIndent(t);const i=[];if(super.generate(n),1===this.LINES.length&&!this.LINES[0])return i;const r=TxtyBlock.blocks(this.LINES);for(const n of TxtyBlock.blocks(this.LINES)){const t=this.isTree(n)?new TxtyTreeParser:new TxtyLinesParser;i.push(t.generateFromLines(n,this.INDENT))}return i}isTree(n){return n.some(n=>n.startsWith(this.INDENT))}}class TxtyBlock{static blocks(n){const t=this.ranges(n);return this.ranges(n).map(t=>n.slice(t.begin,t.end).filter(n=>n))}static ranges(n){if(!Array.isArray(n))throw new TxtyError(`引数LINESは配列であるべきです。`);if(0===n.length)return[];if(1===n.length)return[{begin:0,end:1}];const t=[];let[i,r]=[0,0,0];for(let u=0;u<n.length;u++)if(r++,!n[u]){for(t.push({begin:i,end:r});!n[u];)u++;if(u>=n.length)break;i=u;r=u}return t.push({begin:i,end:n.length}),t}}
